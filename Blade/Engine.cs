using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using IO = System.IO;
using System.Runtime.InteropServices;

//This file is part of the Blade word prediction engine
//Copyright (C) 2012  ACE Centre Oxford

//This program is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program.  If not, see <http://www.gnu.org/licenses/>.

namespace Blade
{

	#region Interfaces for COM
	[ComVisible(true), Guid("08c44866-360b-4dbb-a0d7-ad1348e93973")]
	public enum Notification
	{ // these codes are sent as parameter
		BaseDataMissing, // indicates that the base data could not be found, and the engine has initialised to null data
		CannotOptimiseBaseDataMissing, // as above - base data file is required when tidying user data
		OptimiseFailed, // some other error during optimisation.  Data saved without optimising
		StartSaveOptimise, // called before the slow optimisation starts if SaveData decides to do optimisation
		EndSaveOptimise,
		LoadUserDataFailed, // indicates failure to load main prediction data file, even though the file existed (or ... There was an error checking if the file existed)
		OptimiseDueToBaseDataChanged
	}

	[ComVisible(true), Guid("5663CEE3-BD38-43ab-94B4-EB04354287AB")]
	public enum Cases
	{ // possible settings for whether the text are generated in upper or lower case
		Lower,
		Normal,
		InitialLetter,
		NextInitialLetter,
		Upper
	}

	[ComVisible(true), Guid("dbf6b91d-77e3-4122-9e9f-be7caba102bc")]
	public interface INotification
	{// Engine sends some message back out through this interface.  An instance should be passed to Initialise
	 // done as interface rather than events as this seems simpler if called through COM
	 // this is not essential, and SAW does not bother with this
		void Notify(Notification eState);
		bool Learning(string strText); // this is passed all the text given to LearnLine.  Return false to block this
									   // LearnLine is called by TrackCharacterTyped, and when saving data or clearing TrackedMessage
	}

	[ComVisible(true), Guid("0230d581-d0f1-490f-b7f5-b4a4dd9a4a3c")]
	public interface IEngine
	{ //see the matching functions within class Engine for explanation
		void Initialise(string baseData, INotification pNotify, string settings);
		void SaveData(bool canClean);
		int PredictCOM(string current); // generates predictions and returns the number available
		string GetLastPrediction(int intIndex); // retrieves one of the predicted words generated by the above function, index is 0-based
		string GetLastPredictions(string strSeparator); // retrieves all of the last predictions from PredictCOM, separated by strSeparator
														// if any of the words would have contained strSeparator it is removed
		string LastPredictPartialWord();
		void LearnLine(string strLine, int intSessionHash);
		bool AlphabeticalResults { get; set; }
		int NumberPredictions { get; set; }
		bool OmitPreviousSuggestions { get; set; }
		bool SimpleSingleLetter { get; set; }
		int MinimumLength { get; set; }
		int MinimumGain { get; set; }
		int PunctSpace { get; set; }
		Cases Case { get; set; }
		string Language { get; set; }
		bool Suspend { get; set; }
		void SetSettings(string strSettings);

		void TrackCharacterTyped(char ch, int sessionHash); // can pass 0 for session hash to use a default.  This calls LearnLine as appropriate
		void TrackNewMessage();
		string TrackedMessage { get; set; }

		void Type(string strSelected, bool bolUpdateTracked);

		void EditUserWordList();
	}
	#endregion

	[ComVisible(true), ClassInterface(ClassInterfaceType.None), ComDefaultInterface(typeof(IEngine)), Guid("b2907a79-329a-4543-ae0b-2459b3801f05")]
	public class Engine : IEngine
	{
		internal Tree MainData; // base data + user data.  Base data not loaded as such
		internal Tree UserData;
		internal Recency UserRecency;
		internal Abbreviations UserAbbreviations;
		private string m_UserFolder;
		private string m_BaseData;
		private INotification m_pNotify;
		private string m_strCulture; // culture currently used - but might just be 2 letters (ie lang) if user specified
		private string m_RawBaseFile; // base data file as specified to Initialise with %lang% part
		private Cases m_eCase = Cases.Normal;
		// not built into release builds.  If USELOG is true this will record all learning and editing in frmListEdit
		private IO.StreamWriter m_log;
		private const bool USELOG = false;// true;//

		#region Initialisation, close down, optimisation
		public void Initialise(string baseData, INotification pNotify)
		{
			Initialise(baseData, pNotify, null);
		}

		public void Initialise(string baseData, INotification pNotify, string settings)
		{ // status messages may be sent to pNotify, in this function and others.  This may be null
			m_strCulture = System.Globalization.CultureInfo.CurrentUICulture.Name;
			m_RawBaseFile = baseData;
			if (!string.IsNullOrEmpty(settings))
				SetSettings(settings); // note will not trigger reload as long as m_BaseData = null
			m_UserFolder = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Blade";
			if (!IO.Directory.Exists(m_UserFolder))
			{
				//Debug.WriteLine("Creating user data folder: " + m_UserFolder);
				IO.Directory.CreateDirectory(m_UserFolder);
			}
			m_pNotify = pNotify;

			if (USELOG)
			{
				m_log = new IO.StreamWriter(m_UserFolder + "\\blade-log.txt", true);
				m_log.AutoFlush = true;
				m_log.WriteLine();
				m_log.WriteLine("Starting Blade " + DateTime.Now.ToString());
			}

			InitialiseData();
			UserRecency = new Recency(MainData);
			if (IO.File.Exists(RecencyFile))
				UserRecency.LoadFrom(RecencyFile);

			// just avoiding a static constructor in Token (allegedly this slows it down) (difference was slight in practice)
			Token.Start = new Token("-start-", false, null, CharType.None, 0) { Hash = Node.START };
		}

		private void InitialiseData()
		{ // part of Initialise which can be reused if language changes
			m_BaseData = ResolveLanguageFile(m_RawBaseFile);
			if (m_BaseData == null)
			{
				m_BaseData = m_RawBaseFile; // if no meaningful file, continue using baseData which will initialise to null data and send a notification
				Log("No base file found, using: " + m_RawBaseFile);
			}
			else
				Log("Base data=" + m_BaseData);

			try
			{
				// try and load the user data files first
				if (IO.File.Exists(UserFile(false)))
					UserData = Tree.Read(UserFile(false));
				else
				{
					Log("Blade: no user data found at " + UserFile(false) + ".  Initialising user learned data to a blank list.");
					UserData = new Tree();
				}
			}
			catch (Exception ex)
			{
				m_pNotify?.Notify(Notification.LoadUserDataFailed);
				Log("Load main user data failed: " + ex);
				UserData = new Tree();
			}

			// if we have a main data file (contains base data plus user data) it is loaded; otherwise we revert to the original base data
			MainData = null;
			try
			{
				string combinedFile = UserFile(true);
				Log("Combined file = " + combinedFile + ", exists = " + IO.File.Exists(combinedFile));
				if (IO.File.Exists(combinedFile))
				{
					MainData = Tree.Read(combinedFile);
					try
					{
						if (m_BaseData != "") // this condition isn't critical at runtime as the error handler will deal with it; but it stops a debug build interrupting with silly errors
						{
							int baseRandom = Tree.ReadRandom(m_BaseData);
							if (baseRandom != MainData.m_intBasedOn)
							{
								Log("Blade: combined data at " + UserFile(true) + " will be discarded and rebuilt.  The base data has changed.");
								m_pNotify?.Notify(Notification.OptimiseDueToBaseDataChanged);
								MainData = null;
							}
						}
					}
					catch { } // ignore any errors here - if we cannot access the base data file we don't want to abandon the main data file for a rebuild!
				}
			}
			catch (Exception ex)
			{
				m_pNotify?.Notify(Notification.LoadUserDataFailed);
				Log("Load combined user data failed: " + ex);
			}

			// if the main data wasn't loaded for any reason, it is now reloaded from the base data (possibly with the user data)
			if (MainData == null)
			{
				Log("Blade: no combined data was loaded from " + m_UserFolder + "\\Data.bin.  Loading default base data to use in predictions.");
				Optimise(0);
				if (MainData == null) // will happen if the base data could not be loaded either
					MainData = new Tree();
			}

			// and finally load abbreviations
			string strAbbreviations = m_UserFolder + "\\Abbreviations.bin";
			if (IO.File.Exists(strAbbreviations))
			{
				try
				{ UserAbbreviations = Abbreviations.Read(strAbbreviations); }
				catch (Exception ex)
				{
					Log("Failed to load abbreviations: " + ex);
					UserAbbreviations = new Abbreviations();
				}
			}
			else
				UserAbbreviations = new Abbreviations();
			m_strLastPartial = "";
			if (m_bolMonitor)
				UpdateMonitor("Initialised.  " + MainData.CountHeadWords + " total words (F=" + MainData.TotalFrequency + ").  " + UserData.CountHeadWords.ToString() + " user words.");

		}

		public void SaveData(bool canClean)
		{ // closes the engine and saves the data.  The parameter indicates whether it is acceptable to do an automatic data cleaning
		  // cycle.  This may be significantly slow (at least several seconds)
			Log("SaveData(" + canClean.ToString() + ")");
			if (m_Current != "")
			{ // if the message tracking was being used, learn from any last bit of typing
				LearnLine(m_Current, 0);
				m_Current = "";
			}
			if (MainData.Changed && OptimisationNeeded >= 3 && canClean)
			{ // try and optimise before saving
				m_pNotify?.Notify(Notification.StartSaveOptimise);
				Optimise(0);
				m_pNotify?.Notify(Notification.EndSaveOptimise);
			}
			if (MainData.Changed) MainData.Write(UserFile(true), true);
			if (UserData.Changed) UserData.Write(UserFile(false), true);
			// recency not stored.
			UserRecency.Write(RecencyFile);
			GC.Collect();
			RemoveMonitor(); // needed here as we don't have an explicit Dispose/Close (not needed except for this debug tool)
		}

		public int OptimisationNeeded
		{ // returns a value showing how urgently data needs to be optimised, runs from 0 to 4
			get
			{
				int intThreshold = Math.Min(Math.Max(UserData.TotalFrequency * 3, 1000), 100000);
				// amount that will trigger optimise (return value = 2).  Will trigger after 1000, another 3000, 9000, 27000, 81000, and then every 100000
				if (MainData.Unoptimised == 0) return 0; // 0 = no need.  A call to Optimise will be ignored
				if (MainData.Unoptimised < intThreshold / 20) return 1; // 1 = no need.
				if (MainData.Unoptimised < intThreshold) return 2; // 2 = significant data to optimise (5000+)
				if (MainData.Unoptimised < intThreshold * 10) return 3; // 3 = urgent (100000+)
				return 4; // critical further learning may be ignored
			}
		}

		public void Optimise(int maxWords)
		{
			Optimise(maxWords, null);
		}

		private void Optimise(int maxWords, Tree objBase)
		{ // if intWords is <= 0 then a default value is used (the greater of 2/3 the language base data and 10,000)
		  // objBase usually null, but can be provided if base data already loaded
			Log("Optimise(" + maxWords + ")");
			if ((m_BaseData != "" && IO.File.Exists(m_BaseData)) || objBase != null)
			{
				try
				{
					// reload base data.  Add entire user data, and then optimise the combined
					// this way low frequency user data is kept for the future, but doesn't affect predictions until it
					// gains frequency
					if (objBase == null)
						objBase = Tree.Read(m_BaseData);
					if (MainData != null)
						objBase.File = MainData.File;
					if (maxWords < 100)
						maxWords = Math.Max(10000, (2 * objBase.CountHeadWords) / 3);
					objBase.AddUserData(UserData);
					objBase.Optimise(maxWords);
					objBase.m_intBasedOn = objBase.m_intRandom; // if although this looks like it is referencing itself, it doesn't because the loaded copy of objBase will be re-saved as a different file, and its own random will then change
																// user data never optimised - it is always kept
					MainData = objBase; // new data only used once everything succeeded
				}
				catch (Exception e)
				{
					Log(e.ToString());
					m_pNotify?.Notify(Notification.OptimiseFailed);
				}
			}
			else
				m_pNotify?.Notify(Notification.CannotOptimiseBaseDataMissing);

		}

		//private System.IO.FileSystemWatcher m_objFileWatcher; this doesn't work - I think because no message loop in the DLL (worked in a quick test app)
		private Process m_objEditProcess = null;
		public void EditUserWordList()
		{ // launches a Blade.userEdit application to edit the word lists
		  // SAW needs to open the editor in a separate EXE so that SAW can continue scanning
			Log("Request open editor");
			if (m_objEditProcess != null && !m_objEditProcess.HasExited)
			{
				Log("Rejected already running");
				System.Windows.Forms.MessageBox.Show("Editor is already running.");
				return;
			}
			SaveData(false); // so that EXE can load the current data!
			Log("Closing log and starting editor");
			CloseLog();
			ProcessStartInfo objInfo = new ProcessStartInfo(IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location) + "\\Blade.UserEdit.exe");
			objInfo.Arguments = "\"" + m_RawBaseFile + "\"";
			m_objEditProcess = Process.Start(objInfo);
		}

		public System.Windows.Forms.Form StartEditUserWordListInProcess()
		{ // opens editing dialog modally.  Used by Blade.UserEdit wrapper EXE to start edit
		  // caller should call SaveData if form returns OK
		  // could also be used in other apps.
			Log("StartEditUserWordListInProcess");
			Tree objBase;
			try
			{ objBase = Tree.Read(m_BaseData); }
			catch (Exception e)
			{
				objBase = new Tree(); // frmListEdit requires an object even if it is empty
				Log(e.ToString());
			}
			return new frmListEdit(this, UserData, MainData, objBase, UserAbbreviations, UserRecency);
		}

		public void SaveEditUserWordListChanges()
		{// called if users OKs any changes from form in above function
			Log("SaveEditUserWordListChanges");
			SaveData(true);
			UserAbbreviations.Write(m_UserFolder + "\\Abbreviations.bin", true);
		}

		public void CloseLog()
		{
			if (m_log != null)
			{ m_log.Close(); m_log = null; }
		}

		~Engine()
		{
			m_log?.Close();
			m_log = null;
			RemoveMonitor();
		}

		#endregion

		#region Lower level loading saving and cleaning
		// these functions are mostly public, but not necessarily needed by applications
		private void LoadBaseData()
		{
			if (m_BaseData != "" && IO.File.Exists(m_BaseData))
				MainData = Tree.Read(m_BaseData);
			else
			{
				MainData = new Tree();
				if (m_pNotify != null)
					m_pNotify.Notify(Notification.BaseDataMissing);
			}
		}

		private string ResolveLanguageFile(string file)
		{ // if the input file contains "%lang%" (case sensitive) this returns a string containing a valid file
		  // with this replaced by a language code, either a specific culture (en-us) or just the language (en)
		  // returns null if no matching file can be found
			if (!file.Contains("%lang%")) return file;
			try
			{
				// try complete culture name if specified in m_strLanguage
				if (m_strCulture.Length > 2 && IO.File.Exists(file.Replace("%lang%", m_strCulture)))
					return file.Replace("%lang%", m_strCulture);
				// try just first two characters (language)
				string strTest = m_strCulture.Substring(0, 2);
				if (IO.File.Exists(file.Replace("%lang%", strTest)))
					return file.Replace("%lang%", strTest);
				// see if there is any culture within this lang
				foreach (string strTemp in IO.Directory.GetFiles(IO.Path.GetDirectoryName(file), IO.Path.GetFileName(file).Replace("%lang%", strTest + "-*")))
					return strTemp; // just returns the first matching file
									// see if there is ANY file which matches, for any language
				foreach (string strTemp in IO.Directory.GetFiles(IO.Path.GetDirectoryName(file), IO.Path.GetFileName(file).Replace("%lang%", "*")))
					return strTemp; // just returns the first matching file
				return null; // there are no files matching file with "%lang%" replaced
			}
			catch
			{ return null; }
		}

		public void EraseUserDataFiles()
		{ // wipes all user data, both in memory and on disc
			if (IO.File.Exists(UserFile(true)))
				IO.File.Delete(UserFile(true));
			if (IO.File.Exists(UserFile(false)))
				IO.File.Delete(UserFile(false));
		}

		public void ClearRecency()
		{
			UserRecency.Clear();
		}

		private string UserFile(bool main)
		{ // returns filename for data file given language.
		  // main = false, is UserData.bin (user's typing).  main = true this is combined data file
			if (main)
				return m_UserFolder + "\\Data-" + m_strCulture.Substring(0, 2) + ".bin";
			return m_UserFolder + "\\UserData-" + m_strCulture.Substring(0, 2) + ".bin";
		}

		private string RecencyFile => m_UserFolder + "\\Recency.bin";

		public void Log(string line)
		{
			Debug.WriteLine(line);
			m_log?.WriteLine(line);
		}

		#endregion

		#region Prediction
		private const int MAXIMUM_LENGTH = 150; // most characters to consider
		private string m_strLastPrediction = ""; // remember last predictions to allow ignoring these words this time
		private string m_strLastPartial = ""; // the part of the last text treated as the current word
		private List<int> m_colLastPredictionsText = null; // hash codes of the last returned predictions so they can be ignored next time (BEFORE conversion to uppercase if necessary)
		private Frequency m_objTotalFrequency = null;
		private List<Prediction> m_LastPredictions = null;
		private bool m_bolAutoCaps = false; // true if the last prediction was capitalised because we appear to be at the beginning of a sentence

		public List<String> Predict(string current)
		{ // current should be current text INCLUDING partial final word
			m_bolAutoCaps = false;
			if (m_objEditProcess != null && m_objEditProcess.HasExited)
			{ //check if editor was open, but has been closed
				if (USELOG && m_log == null)
				{ m_log = new IO.StreamWriter(m_UserFolder + "\\blade-log.txt", true); m_log.AutoFlush = true; }
				Log("Detected close of editor - log reopened");
				if (m_objEditProcess.ExitCode == 1) // 1 means saved.  Other codes (usually 0) mean no save
				{
					Log("Detected save of user word list edit.  Re-initialising Blade data");
					InitialiseData();
				}
				m_objEditProcess.Dispose();
				m_objEditProcess = null;
			}
			//Debug.WriteLine("Predicting, length=" + current.Length.ToString());
			if (current == "")
			{
				m_colLastPredictionsText = null;
				m_LastPredictions = null;
				m_strLastPartial = "";
				UpdateMonitor("");
				return new List<string>();
			}
			if (current.Length > MAXIMUM_LENGTH)
				current = current.Substring(current.Length - MAXIMUM_LENGTH, MAXIMUM_LENGTH);
			if (m_colLastPredictionsText != null)
			{ // check that we are predicting 
				if (m_bolOmitPreviousSuggestions == false
					|| m_strLastPrediction == ""
					|| current.LastIndexOf(m_strLastPrediction) != current.Length - m_strLastPrediction.Length - 1)
					m_colLastPredictionsText = null; // we are not searching for a revision of the previous
			}
			m_strLastPrediction = current; // ready for next time
			if (m_strLastPrediction.Length > MAXIMUM_LENGTH - 10)
				m_strLastPrediction = m_strLastPrediction.Substring(10);
			Token last = Tree.SplitWords(current);
			if (last == null) // can be (eg) just a tab character
			{
				m_colLastPredictionsText = null;
				m_LastPredictions = null;
				m_strLastPartial = "";
				UpdateMonitor("");
				return new List<string>();
			}

			string partialWord = ""; // partial word typed so far
			if (Tree.GetCharType(current[current.Length - 1]) != CharType.WhiteSpace)
			// last item is partial token
			{
				partialWord = last.OriginalText;
				last = last.Previous;
			}
			if (partialWord == "")
				m_colLastPredictionsText = null; // starting new word - don't toggle ignored predictions
			if (last == null)
				last = Token.Start;
			else
			{
				last.SplitSentence(); // truncates at sentence boundary (we can ignore any previous sentence it returns)
				if (last.Text == "." || last.Text == "?" || last.Text == "!")
					m_bolAutoCaps = true;
			}
			m_strLastPartial = partialWord;

			// it returns somewhat more data than is needed externally
			UpdateMonitor(last.LineText());
			m_LastPredictions = MainData.Predict(last, partialWord, m_intNumberPredictions, UserRecency, m_colLastPredictionsText,
				m_bolSimpleSingleLetter && partialWord.Length == 1 ? 0 : 10,
				Math.Max(m_intMinimumLength, m_intMinimumGain + partialWord.Length),
				out m_objTotalFrequency);
			// will be sorted in descending freq
			if (m_bolAlphabeticalResults)
				m_LastPredictions.Sort(new Prediction.AlphabeticalSort());
			m_colLastPredictionsText = new List<int>();
			List<string> strings = new List<string>();
			foreach (Prediction prediction in m_LastPredictions)
			{
				if (prediction.Text.Length > 0) // this is included as a sanity check, partly because it would crash InitialLetter if the text was empty
				{
					strings.Add(CaseConvert(prediction.Text, partialWord));
					m_colLastPredictionsText.Add(Tree.GetHash(prediction.Text));
				}
			}
			//if (m_bolAlphabeticalResults)
			//    colStrings.Sort();
			return strings;
		}

		public string LastPredictPartialWord()
		{ // returns the text from last call to Predict which was considered to be the "current" word
		  // i.e. this is the text which should be replaced by the predicted word.  The prediction will always start with this
			return m_strLastPartial;
		}

		public int PredictCOM(string current)
		{ // way of calling Predict which is more COM friendly
		  // this function returns the number of predictions found (may be less than the requested number, and can be 0)
		  // GetPrediction can then be used to retrieve them by index
			try
			{
				int n = Predict(current).Count; // the Predict function has stored the predictions in m_LastPredictions
				if (m_bolMonitor && m_frmMonitor != null)
					m_frmMonitor.SetPredictions(m_strLastPartial + " = " + GetLastPredictions("/"), false);
				return n;
			}
			catch (Exception ex) // was added just for a specific test, but actually this is probably a good idea - raising the error crashes SAW.
			{
				Log(ex.ToString());
				if (m_bolMonitor && m_frmMonitor != null)
					m_frmMonitor.SetPredictions("Error: " + ex.Message, true);
			}
			return 0;
		}

		public string GetLastPrediction(int intIndex)
		{
			if (intIndex < 0 || intIndex >= m_LastPredictions.Count)
				throw new ArgumentException();
			return CaseConvert(m_LastPredictions[intIndex].Text, m_strLastPartial);
		}

		private string CaseConvert(string strPrediction, string strPartialWord)
		{ // applies m_eCase to the given string
		  // strPartialWord needed since if it was capitalised all words returned will be, even if case = Lower
			if (strPrediction.Length == 0) return ""; // might crash InitialLetter below
			Cases eCase = m_eCase;
			if (strPartialWord.Length > 0 && char.IsUpper(strPartialWord[0]))
			{
				if (eCase == Cases.Normal)
					eCase = Cases.InitialLetter;
				if (strPartialWord.Length >= 2 && strPartialWord.ToUpper() == strPartialWord && eCase != Cases.Lower)
					eCase = Cases.Upper;
			}
			if (m_bolAutoCaps && eCase == Cases.Normal) // we appear to be at the beginning of a sentence
				eCase = Cases.InitialLetter;
			switch (eCase)
			{
				case Cases.Lower: return strPrediction.ToLower();
				case Cases.Upper: return strPrediction.ToUpper();
				case Cases.InitialLetter:
				case Cases.NextInitialLetter:
					//if (strPrediction == strPrediction.ToUpper()) return strPrediction; // words already in all caps are not lowered
					return strPrediction.Substring(0, 1).ToUpper() + strPrediction.Substring(1);
				default: return strPrediction;
			}
		}

		public string GetLastPredictions(string strSeparator)
		{ // also retrieves the last predictions from Predict
			if (m_LastPredictions == null)
				return "";
			if (strSeparator == "") // DOH!
				strSeparator = "|";
			StringBuilder output = new StringBuilder(200);
			for (int intIndex = 0; intIndex < m_LastPredictions.Count; intIndex++)
			{
				if (intIndex > 0)
					output.Append(strSeparator);
				output.Append(CaseConvert(m_LastPredictions[intIndex].Text, m_strLastPartial));
			}
			return output.ToString();
		}

		public void LearnLine(string line, int sessionHash)
		{ // at the end of a sentence or line or similar the GUI should pass the completed message for learning
			if (sessionHash == 0)
				sessionHash = line.GetHashCode();
			if (string.IsNullOrEmpty(line))
				return;
			if (m_pNotify != null)
				if (!m_pNotify.Learning(line))
					return;
			Log("LearnLine: " + line);
			UserData.AnalyseLine(line, sessionHash); // although these will perform SplitWords, as below, we can't pass in the split up version because AnalyseLine modifies the list it is working on
			MainData.AnalyseLine(line, sessionHash);
			Token token = Tree.SplitWords(line); // text broken up into "words"
			while (token != null)
			{ // is actually had the last word in the sentence first, but that won't make much difference
				UserRecency.Add(token.Hash);
				token = token.Previous;
			}
		}

		#endregion

		#region Settings
		private bool m_bolAlphabeticalResults = false;
		private int m_intNumberPredictions = 8;
		private bool m_bolOmitPreviousSuggestions = false; // if true then words which were predicted with one letter fewer are omitted next time
		private bool m_bolSimpleSingleLetter = false; // if true after one letter predictions don't use bigrams etc - which means that list is largely fixed for each letter
		private int m_intMinimumLength = 0; // only predicts words at least this long
		private int m_intMinimumGain = 0; // only predicts words this much longer than chars typed - default 0 will predict even if user has typed entire word
		private int m_intMaxPunctAutoSpace = 0; // maximum number of spaces to automatically add via SendKeys after any punctuation passed to TrackCharacterTyped
												// . and ? can add 2.  All other punct is limited to 1 regardless of this.
		private bool m_Suspend = false; // if set to true characters sent to the tracking are ignored

		public bool AlphabeticalResults
		{ get { return m_bolAlphabeticalResults; } set { m_bolAlphabeticalResults = value; } }

		public int NumberPredictions
		{
			get { return m_intNumberPredictions; }
			set
			{
				if (value < 1 || value > 100)
					throw new ArgumentException();
				m_intNumberPredictions = value;
			}
		}

		public bool OmitPreviousSuggestions
		{ get { return m_bolOmitPreviousSuggestions; } set { m_bolOmitPreviousSuggestions = value; } }

		public bool SimpleSingleLetter
		{ get { return m_bolSimpleSingleLetter; } set { m_bolSimpleSingleLetter = value; } }

		public int MinimumLength
		{ get { return m_intMinimumLength; } set { m_intMinimumLength = value; } }

		public int MinimumGain
		{ get { return m_intMinimumGain; } set { m_intMinimumGain = value; } }

		public int PunctSpace
		{ get { return m_intMaxPunctAutoSpace; } set { m_intMaxPunctAutoSpace = Math.Min(Math.Max(value, 0), 2); } }

		public Cases Case
		{ get { return m_eCase; } set { m_eCase = value; } }

		public string Language
		{
			get { return m_strCulture; }
			set
			{
				if (value.Length < 2 || value == m_strCulture || value == m_strCulture.Substring(0, 2)) return; // first condition because this would confuse Resolve...
				if (MainData != null) // condition needed in case this is set during Initialise - in which case saving old data won't work!
					SaveData(false);
				m_strCulture = value;
				if (MainData != null)
					InitialiseData();
			}
		}
		// if adding any more properties, remember to update SetSettings

		public bool Suspend
		{
			get { return m_Suspend; }
			set
			{
				m_Suspend = value;
				m_Current = ""; // after suspending make sure we start with a blank message
				m_strLastPartial = "";
				m_strLastPrediction = "";
				m_colLastPredictionsText = null;
			}
		}

		public void SetSettings(string strSettings)
		{ // can set any or all of the above properties using a string in the form "setting=value,setting2=value2" etc
			if (strSettings == null) return;
			strSettings = strSettings.ToLower().Replace((char)10, ',').Replace((char)13, ','); // we will accept line breaks instead of ,
			string[] aSettings = strSettings.Split(',');
			foreach (string strSetting in aSettings)
			{
				if (strSetting != "")
					try
					{
						string[] aParts = strSetting.Split('=');
						if (aParts.Length != 2) throw new Exception("Each setting must be in the form 'setting=value'");
						aParts[0] = aParts[0].Trim();
						aParts[1] = aParts[1].Trim();
						switch (aParts[0])
						{
							case "alphabeticalresults": AlphabeticalResults = ParseBool(aParts[1]); break;
							case "numberpredictions": NumberPredictions = ParseInt(aParts[1]); break;
							case "omitprevioussuggestions": OmitPreviousSuggestions = ParseBool(aParts[1]); break;
							case "simplesingleletter": SimpleSingleLetter = ParseBool(aParts[1]); break;
							case "minimumlength": MinimumLength = ParseInt(aParts[1]); break;
							case "minimumgain": MinimumGain = ParseInt(aParts[1]); break;
							case "monitor":
								m_bolMonitor = ParseBool(aParts[1]);
								if (!m_bolMonitor && m_frmMonitor != null)
									RemoveMonitor();
								break;
							case "case":
								switch (aParts[1])
								{
									case "lower": Case = Cases.Lower; break;
									case "upper": Case = Cases.Upper; break;
									case "initialletter": Case = Cases.InitialLetter; break;
									case "nextinitialletter": Case = Cases.NextInitialLetter; break;
									case "normal": Case = Cases.Normal; break;
								}
								break;
							case "language": Language = aParts[1]; break;
							case "punctspace":
								switch (aParts[1])
								{
									case "off":
									case "0": m_intMaxPunctAutoSpace = 0; break;
									case "single":
									case "1": m_intMaxPunctAutoSpace = 1; break;
									case "double":
									case "2": m_intMaxPunctAutoSpace = 2; break;
								}
								break;
							case "suspend":
								if (aParts[1].ToLower() == "toggle")
									Suspend = !Suspend;
								else
									Suspend = ParseBool(aParts[1]); break;
							default: Log("Unknown setting: " + aParts[0]); break;
						}
					}
					catch (Exception)
					{ Log("Blade: failed to apply setting: '" + strSetting + "'"); }
			}
		}
		private bool ParseBool(string strValue)
		{ // the value will always have been converted to lowercase already
			switch (strValue)
			{
				case "true": return true;
				case "false": return false;
				default: throw new Exception("Invalid boolean value: " + strValue);
			}
		}
		private int ParseInt(string strValue)
		{
			int intValue;
			if (!int.TryParse(strValue, out intValue))
				throw new Exception("Invalid integer value: " + strValue);
			return intValue;
		}
		#endregion

		#region Optional: Tracking message based upon keys
		// section is optional.  It supports tracking the "current" message based upon keypresses.
		// For example, SAW receives every keypress from a global key hook, whether or not it was involved in typing the key
		// and uses these functions to record the recent text which should be passed to Predicts
		private string m_Current = "";
		private int m_intDefaultSessionHash = DateTime.Now.GetHashCode();
		private bool m_IsWordSelected = false;

		public void TrackCharacterTyped(char ch, int sessionHash)
		{ // this processes backspace, but not delete (forwards).  Mainly because we should probably ignore delete anyway, but also SAW doesn't receive this key
			if (m_Suspend) return;
			if (m_Sending.Length > 0)
			{
				if (m_Sending[0] == ch)
				{
					m_Sending = m_Sending.Substring(1);
					return; // because on SOME machines generated keys are echoed back, but not on others
				}
				else if (m_Sending.StartsWith("{BS}") && ch == (char)8)
				{
					m_Sending = m_Sending.Substring(4);
					return;
				}
			}
			int spaces = 0; // spaces added by this fn (only after punct)
			if (sessionHash == 0)
				sessionHash = m_intDefaultSessionHash;
			string send = "";// any text to be sent must be handled with care as it will call back in here to notify the keys

			if (m_IsWordSelected && (ch == (char)8 || ch == (char)1))
			{// in a nasty bit of hacking, I've made the key hook send character 1 for delete
			 // (because there is no character code for control this)
			 // either of these might follow control + shift + to delete the last word
			 // find how much of the text to keep...
				int keep = m_Current.Length;
				// need to remove any trailing whitespace
				while (keep > 0 && char.IsWhiteSpace(m_Current[keep - 1]))
					keep--;
				// then remove the next word
				while (keep > 0 && !char.IsWhiteSpace(m_Current[keep - 1]))
					keep--;
				// LibreOffice would also then remove any more whitespace; but it seems almost unique in that
				m_Current = m_Current.Substring(0, keep);
				m_IsWordSelected = false;
			}
			else if (ch == (char)8) // backspace
			{
				if (m_Current.Length > 0)
					m_Current = m_Current.Substring(0, m_Current.Length - 1);
			}
			else if (ch == (char)2)
			{ // in a nasty bit of hacking, I've made the key hook send character 2 for control + shift + left arrow
			  // this is used in scripts followed by delete or backspace to delete the last word
			  // see above
				m_IsWordSelected = true;
			}
			else if (ch == (char)13 || ch == (char)0x1b || ch == (char)1) // enter or escape or delete (see above)
			{ // escape does need to learn as this is sent for many other key combinations (ctrl-backspace, page up/down etc)
			  // any use of delete except the context above is counted as breaking the prediction context.
				LearnLine(m_Current, sessionHash);
				m_Current = ""; // enter starts a new message/sentence.  If the user backspaces into the enter later - tough!
				m_IsWordSelected = false;
			}
			else
			{
				m_IsWordSelected = false;
				if (char.IsPunctuation(ch)
					&& ch != ' ' && ch != '{' && ch != '(' && ch != '[') // not sure if space counts as punctuation, but just in case
																		 // the { in particular MUST be filtered out as this would confuse SendKeys.  I think it's best not to do this before the other brackets as well
				{ // the last thing typed was done by Type, which added a space.  This is before punctuation we should remove the space again
					spaces = m_intMaxPunctAutoSpace;
					if (ch != '.' && ch != '?' && spaces == 2)
						spaces = 1; // all other punct followed by max of 1 space
					if (m_AutoSpacesAdded > 0) // need to delete space before the punct which was just typed
					{
						// we send 2 backspaces to remove the just typed punctuation and the preceding space, followed by the same punctuation character again 
						// certain characters need to be enclosed in { in SendKeys
						switch (ch)
						{
							case '+':
							case '^':
							case '%':
							case '~':
							case '(':
							case ')':
							case '[':
							case ']':
							case '{':
							case '}':
								send = "{BS}{BS}{" + ch + "}";
								break;
							default:
								send = "{BS}{BS}" + ch;
								break;
						}
						if (m_AutoSpacesAdded == 2) send = "{BS}" + send;
						spaces = Math.Max(spaces, 1);// need to add at least one space to replace the one we deleted
					}

					// and then the spaces...
					if (spaces > 0)
						send += new string(' ', spaces);

					// and update the "current" text
					if (m_AutoSpacesAdded > 0 && m_Current.Length >= (m_AutoSpacesAdded + 1)) // first remove the bits we deleted
						m_Current = m_Current.Substring(0, m_Current.Length - m_AutoSpacesAdded);
					m_Current += ch + new string(' ', spaces);
					m_AutoSpacesAdded = spaces;
				}
				else
					m_Current += ch;
				// check for abbreviations.  Always requires space before the abbreviation
				int intBreak;
				if (m_Current.Length > 1)
				{
					intBreak = m_Current.LastIndexOfAny(new char[] { ' ', '\r', '\n' }, m_Current.Length - 2, m_Current.Length - 1);
					// -1 is a valid result.  Abbreviation starts with character AFTER
				}
				else
					intBreak = -1; // if string is short, treat start of string as possible start of abbreviation
				if (intBreak < m_Current.Length - 1)
				{
					string abbreviation = m_Current.Substring(intBreak + 1);
					string replace = UserAbbreviations?.Lookup(abbreviation) ?? "";
					if (replace != "")
					{
						for (int index = 0; index < abbreviation.Length; index++) // erase the abbreviation itself
							send += "{BS}";
						send += replace;
						m_Current = m_Current.Substring(0, m_Current.Length - abbreviation.Length) + UserAbbreviations[abbreviation];
						if (m_eCase == Cases.NextInitialLetter) // only lasts until end of word
							m_eCase = Cases.Normal;
						if (m_Current.EndsWith(" "))
							spaces = 1;
					}
				}

				// we can't just let it grow indefinitely, but also we can't just split at .
				// The simplest solution is to let the string grow quite large, and then use the existing parsing to regenerate just the last sentence
				if (m_Current.Length > MAXIMUM_LENGTH)
				{
					Token temp = Tree.SplitWords(m_Current);
					string newString;
					if (temp.SplitSentence() == null) // splits and retains just the last sentence
					{ // could not be split at a sentence boundary.  Just use any space
						int index = m_Current.LastIndexOf(' ', 100); // last space within first hundred characters
						if (index > 0)// (deliberately not >=; not much point just taking a single space off the beginning)
							newString = m_Current.Substring(index + 1);
						else
							newString = m_Current;// ! no spaces either
					}
					else
					{// find the first token in the final sentence (excluding the created START token)
						while (temp.Previous != null && temp.Previous.Hash != Token.Start.Hash)
							temp = temp.Previous;
						newString = m_Current.Substring(temp.StartedAt);
					}
					if (newString.Length < m_Current.Length)
					{
						// learn from the text which has been discarded
						string learn = m_Current.Substring(0, m_Current.Length - newString.Length);
						LearnLine(learn, sessionHash);
					}
					m_Current = newString;
				}
				// finally clear InitialLetter mode at end of a word
				if (ch == ' ' && m_eCase == Cases.NextInitialLetter)
					m_eCase = Cases.Normal;
			}
			if (send != "")
			{
				m_Sending = send;
				System.Windows.Forms.SendKeys.SendWait(send);
				// .Send cannot be used because "this application is not handling Windows messages"
				m_Sending = "";
			}
			m_AutoSpacesAdded = spaces;
		}

		public void TrackNewMessage()
		{// resets the recent message to blank if the application knows that the context has changed
			if (m_Suspend) return;
			if (m_Current != "")
				LearnLine(m_Current, m_intDefaultSessionHash);
			m_Current = "";
			m_AutoSpacesAdded = 0;
			if (m_eCase == Cases.NextInitialLetter)
				m_eCase = Cases.Normal;
		}

		public string TrackedMessage
		{
			get { return m_Current; }
			set
			{
				if (m_Current != "" && value == "")
					LearnLine(m_Current, m_intDefaultSessionHash);
				m_Current = value;
				m_AutoSpacesAdded = 0;
			}
		}

		#endregion

		#region Optional: Sending selected item to keyboard
		private int m_AutoSpacesAdded = 0; // Number of spaces added automatically by Type or TrackCharacterTyped
		private string m_Sending = ""; // keys that we have sent

		public void Type(string strSelected, bool bolUpdateTracked)
		{ // sends the necessary key presses to type strSelected. assumes that the predictions were based on the last call to Predict
		  // updates TrackedMessage if and only if bolUpdateTracked
			if (strSelected == "") return;
			if (!strSelected.StartsWith(m_strLastPartial, StringComparison.CurrentCultureIgnoreCase))
				return; // just ignore it if it starts with the wrong text - this is probably better than typing the wrong characters which will leave gibberish on-screen
			if (System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys.CapsLock))
				strSelected = strSelected.ToUpper();
			string strSend = "";
			if (!strSelected.StartsWith(m_strLastPartial) &&
				(m_strLastPartial == m_strLastPartial.ToLower() || strSelected == strSelected.ToUpper()))
			{ // but they don't match on a case-sensitive comparison AND (the user is typing in lower case or it's an all-caps word)
			  // second conditions are to avoid replacing a word typed by the user with one cap with a data-word in lower case
			  // therefore we need to remove the typed characters and replaced them with strSelected to get the correct casing
				for (int intIndex = 0; intIndex < m_strLastPartial.Length; intIndex++)
				{
					strSend += "{BS}";
					if (bolUpdateTracked && m_Current.Length > 0)
						m_Current = m_Current.Remove(m_Current.Length - 1);
				}
			}
			else
				strSelected = strSelected.Substring(m_strLastPartial.Length);
			if (!strSelected.EndsWith(" "))
			{
				strSelected += " ";
				m_AutoSpacesAdded = 1;
			}
			else
				m_AutoSpacesAdded = 0;
			if (bolUpdateTracked)
				m_Current += strSelected;
			strSend += strSelected;
			m_Sending = strSend;
			bool caps = System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys.CapsLock);
			// SendKeys seems to add shift for upper case which is all wrong if caps lock already pressed
			if (caps)
				strSend = "{CAPSLOCK}" + strSend + "{CAPSLOCK}";
			try
			{
				System.Windows.Forms.SendKeys.SendWait(strSend);
				if (m_eCase == Cases.NextInitialLetter) // only lasts until end of word
					m_eCase = Cases.Normal;
				//Debug.WriteLine("Recent message: '" + m_Current + "'");
			}
			finally
			{ m_Sending = ""; }
		}
		#endregion

		#region Support for Blade.Edit
		// these functions must be public for use in Blade.Edit, but are not relevant to an application using this for prediction
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
		public string GetInfoForPrediction(string strPrediction)
		{
			// returns information about the given prediction in the last set returned by Predict
			foreach (Prediction objResult in m_LastPredictions)
				if (objResult.Text == strPrediction)
				{
					System.Text.StringBuilder strResult = new StringBuilder();
					strResult.Append("Total P = ").AppendLine(objResult.Probability.ToString("0.000"));
					for (int intLevel = 0; intLevel < Frequency.MAX_LEVEL; intLevel++)
					{
						if (objResult.FrequencyData.HasResultsAtLevel(intLevel))
						{
							strResult.Append("Level ").AppendLine(intLevel.ToString());
							strResult.Append("Exact: ").AppendLine(FrequencyText(objResult.FrequencyData.Exact[intLevel], m_objTotalFrequency.Exact[intLevel]));
							strResult.Append("Unknown: ").AppendLine(FrequencyText(objResult.FrequencyData.Unknown[intLevel], m_objTotalFrequency.Unknown[intLevel]));
							strResult.Append("Other: ").AppendLine(FrequencyText(objResult.FrequencyData.Other[intLevel], m_objTotalFrequency.Other[intLevel]));
							strResult.AppendLine();
						}
					}
					if (objResult.FrequencyData.RecencyFrequency > 0)
					{
						strResult.Append("Recency freq = " + objResult.FrequencyData.RecencyFrequency.ToString("0.000,00"));
						if (objResult.FrequencyData.RecencyFrequency < 0.01)
							strResult.Append(" : 1 per " + (1 / objResult.FrequencyData.RecencyFrequency).ToString("0"));
						strResult.AppendLine();
					}
					if (objResult.FrequencyData.RecencyAdjust != 0)
						strResult.AppendLine("Recency adjust (multiplier to ln(freq) at each level) = " + objResult.FrequencyData.RecencyAdjust.ToString("0.00"));
					return strResult.ToString();
				}
			// the text was not in the given predictions
			return "No data";
		}

		private string FrequencyText(int intValue, int intTotal)
		{
			if (intTotal == 0)
				return intValue.ToString() + " / 0 ";
			string strText = intValue.ToString() + " / " + intTotal.ToString() + " = " + ((float)intValue / intTotal).ToString("0.000");
			if (intValue * 100 < intTotal && intValue > 0)
				strText += " : 1 per " + (intTotal / intValue).ToString("0");
			return strText;
		}

		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
		public Tree GetDataObject(bool bolUser)
		{ // returns one of the two main data objects.  It is not usually intended that these are accessed directly, but this is needed by the Blade.Edit project
			if (bolUser)
				return UserData;
			else
				return MainData;
		}

		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
		public void Initialise(Tree objMain, Tree objUser, bool bolLoadRecency)
		{ // used by Blade.Edit to explicitly initialise the prediction based upon the data it has in memory
			m_UserFolder = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Blade";
			MainData = objMain;
			UserData = objUser;
			UserRecency = new Recency(MainData);
			if (bolLoadRecency && IO.File.Exists(RecencyFile))
			{
				UserRecency.LoadFrom(RecencyFile);
				UserRecency.DebugDump();
			}
		}

		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
		public void Test(string text, bool learn,
			ref int wordsTested, ref int requiredLetters, ref int wordLength, ref int inDictionary, ref int notInDictionaryLetters,
			IO.StreamWriter output)
		{ // performs a test of prediction on the given text, calculating how many letters must be typed before each word
		  // appears in the top 8 predictions.  The ref integer parameters return the information; all must be initialised to 0 before calling
		  // this the first time.  Multiple calls to this function can be made, each giving it a paragraph of text
		  // note that this function is SLOW - requiring a full prediction every character position in the text
		  // output can be null.  If not a complete list of predictions is written
			MainData.m_intUserRatio = 10;
			Token sentence = Tree.SplitWords(text);
			while (sentence != null)
			{
				Token next = sentence.SplitSentence();
				Token token = sentence;

				while (token != null && token.Hash != Node.START)
				{
					string word = token.OriginalText;
					CharType eType = token.CharacterType;
					token = token.Previous; // now the previous text before the word being predicted
											// We only test if the current "word" is actually a word!
					if (eType == CharType.Letter)
					{
						int letters = 0;
						bool found = false;
						while (letters < word.Length && !found)
						{
							string strTest = token.LineText() + " " + word.Substring(0, letters);
							List<string> colPredictions = Predict(strTest);
							if (output != null && strTest.Trim() != "")
							{
								output.Write(strTest + "* == " + GetLastPredictions("/"));
								if (colPredictions.Contains(word))
									output.Write("   << Matched: " + word);
								output.WriteLine();
							}
							if (colPredictions.Contains(word))
								found = true;
							else
								letters++;
						}
						wordsTested++;
						requiredLetters += letters;
						wordLength += word.Length;
						if (!found && output != null && word.Length > 1) // last condition because we're only trying up to one char less - bit tough getting "I" every time with no letters!
							output.WriteLine(">>> Failed to predict: " + word);
						//Debug.WriteLine(strWord + ": " + intLetters.ToString());
						if (MainData.Entries.ContainsKey(Tree.GetHash(word)) || found) // || bolFound needed due to capitalisation?
							inDictionary++;
						else
							notInDictionaryLetters += word.Length;
						UserRecency.Add(Tree.GetHash(word)); // this is a little bit strange since the words are being passed to the recency backwards
															 // however, it is not expected to make much difference within a sentence
					} // if char is letter
				} // while in this line
				if (learn)
					LearnLine(sentence.LineText(), -1);
				sentence = next;
			} // while objSentence != null
		}
		#endregion

		#region Monitoring Window
		private bool m_bolMonitor = false;
		private frmMonitor m_frmMonitor = null;
		private void UpdateMonitor(string strSentence)// partial in m_strLastPartial
		{
			if (!m_bolMonitor)
				return;
			if (m_frmMonitor == null || m_frmMonitor.IsDisposed)
				m_frmMonitor = new frmMonitor();
			m_frmMonitor.SetContextDisplay(m_strLastPartial, strSentence);
		}

		private void RemoveMonitor()
		{
			if (m_frmMonitor != null)
				m_frmMonitor.Dispose();
			m_frmMonitor = null;
		}


		#endregion
	}
}

